# -*- mode: org; fill-column: 60; -*-
#+STARTUP: showall indent hidestars

* Intro

У нас есть 4 трека, каждый из них может одновременно вести
одно голосование.

[TODO:gmm] не будет паралельных голосований на одном треке?

Голосование может начать кто-то кто обладает правами, при
этом для каждого трека эти права и процедура их проверки
разные. Поэтому я буду подставлять различающееся в один и
тот же шаблон контракта, чтобы DRY.

Предложение считается принятым, если до его окончания не
было получено достаточно возражений.

Tracks variants:
- validators requests
- grant distibution
- payments of rewards
- regular insurance payments

* Contract initialization

Init нужен чтобы определить, кто может добавлять тех, кому
разрешено начинать голосование. По идее, только контракт
всеобщего голосования DAO может сделать это.

[TODO:gmm] - Лучше ли обойтись только assert-ом без init-а?

[TODO:gmm] - Нужен механизм, чтобы поменять адрес такого
контракта?

[TODO:gmm] - Как мне представиться контрактом голосования
DAO, чтобы протестить это? Как написать такой тест?

#+NAME: init
#+BEGIN_SRC vyper :noweb yes
  @external
  def __init__(_admin: address):
      self.admins[_admin] = True
#+END_SRC

* Vote initiation

Начинаем голосование easy-track, вызвая ~start_vote~. Он
вызовет ~check_creds~ чтобы проверить, может ли ~msg.sender~
начинать голосование.

~check_creds~-функции свои для каждого easy-track.

[TODO:gmm] - Минимальное время между попытками одного
пользователя создать новое голосоваине

[TODO:gmm] - Минимальный порог для начала голосования

[TODO:gmm] - Нужно лочить токены, чтобы одними и теми же
токенами нельзя было создавать голосования слишком часто

#+NAME: start_vote
#+BEGIN_SRC vyper :noweb yes
  # Starting vote process
  @external
  def start_vote():
      # Check
      self._check_creds(msg.sender)
#+END_SRC

** Check credentials to start vote

Для каждого трека способ проверки прав для начала
голосования свой

*** validator request

Тот кто хочет начать голосование должен быть
валидатором. Допустим, мы ведем хеш-таблицу валидаторов:

#+BEGIN_SRC vyper :noweb-ref data_for_validators_request
  validators: public(HashMap[address, bool])
#+END_SRC

Тогда нужен список адресов, которые может добавлять и
удалять валидаторов:

#+BEGIN_SRC vyper :noweb-ref data_for_validators_request
  admins: public(HashMap[address, bool])
#+END_SRC

и функции добавления и удаления валидаторов:

#+BEGIN_SRC vyper :noweb-ref validators_ops
  @external
  def add_validator(_param: address):
      assert self.admins[msg.sender], "not an admin"
      self.validators[_param] = True

  @external
  def del_validator(_param: address):
      assert self.admins[msg.sender], "not an admin"
      self.validators[_param] = False
#+END_SRC

И теперь можно проверять адрес на наличие в списке валидаторов

#+NAME: check_creds_validator_request
#+BEGIN_SRC vyper :noweb yes
  <<validators_ops>>

  @internal
  def _check_creds(sender: address):
      assert self.validators[sender], "not a validator"
#+END_SRC

*** grant distibution

Голосование начинается, если удовлетворены требования
пороговой подписи K из N

[TODO:gmm] как написать проверку порога?

*** payments of rewards

[TODO:gmm] Эти пэйменты будет вызывать арагон-агент. Как?

*** regular insurance payments

[TODO:gmm] Тут надо делать периодический вызов? Как?

* Objections

** Avoidance of malicious objections

Существует атака, при которой возражающий может продать
проголосовавшие жетоны и сразу же купить новые, чтобы
проголосовать снова. Чтобы этого не произошло, в контракте
easy-track необходимо обратиться к менеджеру токенов, чтобы
запретить передачу этих токенов до конца голосования.

Еще более экономичный способ - использовать остатки на
момент блока, в котором началось голосование. То есть
голосовать могут только жетоны, которые не были перемещены с
момента начала голосования.

** Send objection function

[TODO:gmm] send_objection fun

[TODO:gmm] проверка не истекло ли время голосования

#+NAME: send_objection
#+BEGIN_SRC vyper
  # Starting vote process
  @external
  def send_objection():
      ...
#+END_SRC

* Expiration of the voting period

[TODO:gmm] - Как я могу получить время, чтобы определить что
голосование пора завершать?

[TODO:gmm] - Если голосование завершено, то здесь нужен
event?

[TODO:gmm] - Подсчет возражений

[TODO:gmm] - Как мне запустить что-то по результатам?

** Objection threshold

[TODO:gmm] Нужен свой порог для каждого трека

* Monitoring of voting

[TODO:gmm] - Как это делать?

* Tangle

[TODO:gmm] - Общие вещи если надо

** validator's requests contract

Сделаем генерацию контракта для validator's requests

#+NAME: validators_request_contract
#+BEGIN_SRC vyper :noweb yes :tangle ./contracts/easy_track_for_validators.vy
  # @version 0.2.8
  # @author Lido <info@lido.fi>
  # @licence MIT

  <<data_for_validators_request>>

  <<init>>

  <<check_creds_validator_request>>

  <<start_vote>>
#+END_SRC
