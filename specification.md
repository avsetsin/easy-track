# Abstract

**Easy Track** is a type of voting where a motion is considered to be passed if the minimum objections threshold hasnâ€™t been exceeded.

**EasyTrack contract** is the main contract, which implements the Easy Track voting mechanism. EasyTrack contract inherits from some OpenZeppelin contracts:

- [AccessControlUpgradeable](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/2af7375b7b2f82224272d823c1151d4d5d0633c4/contracts/access/AccessControlUpgradeable.sol) - to restrict access to some methods only to a set of admin addresses. **Admin of Easy Track** - is an address with granted `DEFAULT_ADMIN_ROLE`. By default, Admin of Easy Track will be Aragon's Voting address.
- [PausableUpgradeable](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/2af7375b7b2f82224272d823c1151d4d5d0633c4/contracts/security/PausableUpgradeable.sol) - to implement the ability to freeze enactment and creation of motions. Pausing allowed for addresses with role `PAUSE_ROLE` and unpausing for addresses with role `UNPAUSE_ROLE`. By default, both roles are assigned to the Admin of Easy Track.
- [UUPSUpgradable](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/9fbc1d71c0ed4c68a0bc160c69df1f85e94d2d8e/contracts/proxy/utils/UUPSUpgradeable.sol) - to implement upgradability. Make upgrades only allowed to the Admin of Easy Track.

Easy Track is strongly inspired by Aragon's Voting and based on Aragon's [EVMScripts](https://hack.aragon.org/docs/aragonos-3-ref#evmscripts) concept. Execution of EVMScripts happens by standalone EVMScriptExecutor contract, which can be called only by EasyTrack and Aragon's Voting contracts. Implementation of EVMScriptExecutor used in EasyTrack contract delegates execution of EVMScripts to Aragon's [CallsScript](https://github.com/aragon/aragonOS/blob/v3.0.0/contracts/evmscript/executors/CallsScript.sol#L20) executor.

In contrast to Aragon's Voting, EasyTrack contract doesn't allow to pass EVMScripts directly, and uses standalone **EVMScript factory** contracts to create EVMScripts. **EVMScript factory** - is a special contract, which implements [IEVMScriptFactory]() interface. Each EVMScript factory has to be registered in the EasyTrack contract before usage on motion creation. Registration of EVMScript factory contracts allowed only to Admins of Easy Track.

To enhance the security of Easy Track each EVMScript factory has its own **Permissions**, which are set once when new EVMScript factory registers in the EasyTrack contract. **Permissions** - is a list of tuples `(address, bytes4)` encoded into a bytes representation. Each tuple `(address, bytes4)` describes a method, which allowed to be called by EVMScript generated by the corresponding EVMScript factory. EasyTrack validates each EVMScript to satisfy permissions and reverts transaction if EVMScript tries to call a method not listed in its permissions.

EasyTrack contract stores motion data in next struct:

```solidity=
struct Motion {
    uint256 id;
    address evmScriptFactory;
    address creator;
    uint256 duration;
    uint256 startDate;
    uint256 snapshotBlock;
    uint256 objectionsThreshold;
    uint256 objectionsAmount;
    uint256 objectionsAmountPct;
    bytes32 evmScriptHash;
}
```

EasyTrack contract doesn't store EVMScripts on-chain but only keccak256 hash of it. On enactment of motion, EasyTrack contract recreates EVMScript using corresponding EVMScript factory and compares the hash of recreated EVMScript with stored hash; if it equals - EasyTrack contract passes EVMScript to EVMScriptsExecutor and reverts in other cases.

The lifecycle of motion in the easy track voting might be described as next:

1. A motion can be started by calling `createMotion(address _evmScriptFactory, bytes _evmScriptFactoryCallData)` function on EasyTrack contract.
2. Upon motion creation, EasyTrack contract calls `createEVMScript(msg.sender, _evmScriptFactoryCallData)` function on the corresponding EVMScript factory contract passing all the data required to generate a motion enactment EVMScript.
3. EVMScript factory smart contract generates the script and returns it to the EasyTrack contract.
4. EasyTrack contract conducts the motion according to the motion settings (i.e. motion duration, objections threshold, and max active motions limit).
5. As soon as the motion duration expires, it becomes possible to enact the motion via `enactMotion(uint256 _motionId, bytes evmScriptFactoryCallData)`.
6. To enact the motion, the EasyTrack contract recreates EVMScript via the corresponding EVMScript factory contract and passes it to the `EVMScriptExecutor` smart contract.

Additionally to the creation, enactment, and objection of motions, EasyTrack contract allows the creator of the motion to cancel it at any time while it wasn't enacted. It might be convenient in some cases: passed wrong data to EVMScript factory on motion creation or inability to enact motion due to the changed state of outer contracts and etc.

Addresses with the role `CANCEL_ROLE` have the right to cancel any motions. EasyTrack contract has two methods for it: to cancel a list of motions or all motions at once. By default `CANCEL_ROLE` grants to Aragon's Voting address.

To exclude the possibility of spamming with motions EasyTrack contract limits the count of active motions. By default, the limit is equal to 12. This value can be changed in the future by the Admin of Easy Track. But the new value can't be greater than 24.

Default enact delay for motions is equal to 48 hours. It might be changed by the Admin of Easy Track, but the new value can't be less than 48 hours.

Default objections threshold is equal to 0.5%. It might be changed by the Admin of Easy Track, but the new value can't be greater than 5%.

# Core Contracts

As it was mentioned above, EasyTrack is the main contract in the implementation of the Easy Track voting model. EasyTrack contract is upgradable, which allows upgrade functionality in the future without state losing and without the necessity to redeploy all contracts. To simplify future updates and minimize the risk of storage collisions all variables of EasyTrack contract are stored in a standalone EasyTrackStorage contract. EasyTracksStorage is a base contract for EasyTrack contract.

To increase the readability and simplicity of the EasyTrack contract group of methods moved to standalone contracts:

- [MotionSettings]() - keeps logic to set objections threshold, max amount of active motions, and time required to allow motion to be enacted.
- [EVMScriptFactoriesRegistry]() - keeps logic to add/remove EVMScriptFactories and create evm scripts.

Such separation helps to keep in EasyTrack contract only methods, directly connected with Easy Track logic. The whole inheritance graph can be seen in the picture below.

<p align="center">
    <img src="https://i.imgur.com/cybYVS2.png" width="480px">
</p>

## EasyTrackStorage

Keeps all variables of the EasyTrack. contract Inherits from OpenZeppelin's `Initializable`, `PausableUpgradeable` and `AccessControlUpgradeable` contracts.

### Storage

Contract stores all variables used in Easy Track. Variables can be split into three groups:

#### Motion Settings Variables

Variables used to control motion duration, max count of active motions, and threshold of objections, required to reject the motion.

- **`uint256 objectionThreshold`** - percent from total supply of governance tokens required to reject motion. Value stored in basis points: 1% == 100. Max allowed value is 5%. Default value is 0.5%.
- **`uint256 motionsCountLimit`** - max count of active motions. Max allowed value is 24. Default value is 12.
- **`uint256 motionDuration`** - minimal time required to pass before enacting of motion. Min allowed value is 48 hours. The default value is 48 hours.

#### EVM Script Factories Variables

Variables used to control the list of allowed EVM Script factories of Easy Track.

- **`address[] evmScriptFactories`** - current list of allowed EVM Script factories.
- **`mapping(address => bytes)`** - evmScriptFactoriesPermissions - permissions of current list of allowed EVMScript factories.

#### Easy Track Variables

Variables used in primary Easy Track actions:

- **`Motion[] motions`** - list of active motions.
- **`IMiniMeToken governanceToken`** - address of governance token. Token has to implement [MiniMeToken]() interface. Only holders of this token can send objections.
- **`IEVMScriptExecutor evmScriptExecutor`** - address of EVMScriptExecutor
- **`mapping(uint256 => mapping(address => bool)) objections`** - stores if motion with given id was objected by given address.

### Methods

#### function \_\_EasyTrackStorage_init(address \_governanceToken, address \_admin) public initializer

Initializes EasyTrackStorage. This method might be called only once. Makes next actions:

- initializes `PausableUpgradable` and `AccessControlUpgradable` contracts
- grants `DEFAULT_ADMIN_ROLE`, `PAUSE_ROLE`, `UNPAUSE_ROLE` and `CANCEL_ROLE` to `_admin` address
- sets default values for variables: `objectionsThreshold`, `motionsCountLimit`, `motionDuration`
- sets value for `governanceToken`.
- emits events `ObjectionsThresholdChanged`, `MotionDurationChanged` and `MotionDurationChanged`

## MotionSettings

Provides methods to update motion settings of Easy Track: motion duration, objections threshold, and limit of active motions. Inherits from `EasyTrackStorage`.

### Methods

#### function setMotionDuration(uint256 \_motionDuration) external onlyRole(DEFAULT_ADMIN_ROLE)

Sets the duration of newly created motions. The minimum value is 48 hours. Can be called only by the Admin of Easy Track.

Events:

```solidity=
event MotionDurationChanged(uint256 _motionDuration);
```

#### function setObjectionsThreshold(uint256 \_objectionsThreshold) external onlyRole(DEFAULT_ADMIN_ROLE)

Sets new objectionsThreshold value. Maximum value is 5%
Can be called only by the Admin of Easy Track.

Events:

```solidity=
event ObjectionsThresholdChanged(uint256 _newThreshold)
```

#### function setMotionsCountLimit(uint256 \_motionsCountLimit) external onlyRole(DEFAULT_ADMIN_ROLE)

Sets new value for `motionsCountLimit`. Max value is 48. Can be called only by the Admin of Easy Track.

Events:

```solidity=
event MotionsCountLimitChanged(uint256 _newMotionsCountLimit)
```

## EVMScriptFactoriesRegistry

Provides methods to add/remove EVMScript factories and contains an internal method for the convenient creation of EVM Scripts. Inherits from `EasyTrackStorage`.

### Methods

#### addEVMScriptFactory(address \_evmScriptFactory, bytes \_permissions) external onlyRole(DEFAULT_ADMIN_ROLE)

Adds new EVM Script Factory to the list of allowed EVMScript factories with given permissions. Can be called only by the Admin of Easy Track.

Events:

```solidity=
event EVMScriptFactoryAdded(address indexed _evmScriptFactory, bytes _permissions)
```

#### removeEVMScriptFactory(address \_evmScriptFactory) external onlyRole(DEFAULT_ADMIN_ROLE)

Removes EVMScript factory from the list of allowed EVMScript factories. Can be called only by the Admin of Easy Track.

Events:

```solidity=
event EVMScriptFactoryRemoved(address indexed _evmScriptFactory)
```

#### getEVMScriptFactories() external view returns (address[])

Returns a list of registered EVMScript factories.

#### isEVMScriptFactory(address \_maybeEVMScriptFactory) external view returns (bool)

Returns if `_maybeEVMScriptFactory` address listed as EVMScript factory or not.

#### \_createEVMScript(address \_evmScriptFactory, address \_creator, bytes \_evmScriptCallData) internal returns (bytes \_evmScript)

Creates EVMScript using `_evmScriptFactory` EVMScript factory with `_evmScriptCallData` parameters. Validates that generated EVMScript meets permissions of corresponding EVMScript factory.

## EasyTrack

Contains main logic of Easy Track. Inherits from `UUPSUpgradeable`, `MotionSettings` and `EVMScriptFactoriesRegistry`.

### Methods

#### function createMotion(address \_evmScriptFactory, bytes memory \_evmScriptCallData) external whenNotPaused returns (uint256 \_newMotionId)

Creates new motion and returns the id of created motion. Passed `_evmScriptFactory` address must be registered as allowed EVMScript factory.

Evens:

```solidity
event MotionCreated(
    uint256 indexed _motionId,
    address _creator,
    address indexed _evmScriptFactory,
    bytes _evmScriptCallData,
    bytes _evmScript
)
```

#### function enactMotion(uint256 \_motionId, bytes memory \_evmScriptCallData) external whenNotPaused

If a motion with a given id wasn't rejected or canceled and time passed from motion creation is greater than the duration of the motion, removes motion and executes script generated by the EVMScript factory associated with motion. To execute EVMScript EasyTrack recreates it with passed `_evmScriptCallData` params via EVMScript factory stored in `motion.evmScriptFactory` property. Transaction will fail if the hash of recreated EVMScript is not equal to `evmScriptHash` stored in motion.

Events:

```solidity=
event MotionEnacted(uint256 indexed _motionId)
```

#### function cancelMotion(uint256 \_motionId) external

Removes motion from list of active motions. Motion can be canceled only by the creator of motion.

Events:

```solidity=
event MotionCanceled(uint256 indexed _motionId);
```

#### function objectToMotion(uint256 \_motionId) external

Submits an objection from `governanceToken` holder. The objection power equals the number of tokens held. Since `governanceToken` is MiniMeToken, it utilizes `balanceOfAt` and `totalSupplyAt` methods to prevent multiple objections submitted with the same tokens. If `objectionsThreshold` has been exceeded, the motion will be deleted and `MotionRejected` event will be emitted.

Events:

```solidity=
event ObjectionSent(
    uint256 indexed _motionId,
    address indexed _voterAddress,
    uint256 _weight,
    uint256 _votingPower
)
event MotionRejected(uint256 indexed _motionId)
```

#### function cancleMotions(uint256[] memory \_motionIds) external onlyRole(CANCEL_ROLE)

Cancels each motion with id contained in the `_motionIds` array. Can be called only by address with granted `CANCEL_ROLE`. If some of the passed ids don't exist skips them. Emits `MotionCanceled` event for each canceled motion.

Events:

```solidity=
event MotionCanceled(uint256 indexed _motionId);
```

#### function cancelAllMotions() external onlyRole(CANCEL_ROLE)

Cancels all active motions. Can be called only by address with granted `CANCEL_ROLE` permission. Emits events `MotionCanceled` for each canceled motion.

Events:

```solidity=
event MotionCanceled(uint256 indexed _motionId);
```

#### function setEVMScriptExecutor(address \_evmScriptExecutor) external onlyRole(DEFAULT_ADMIN_ROLE)

Sets new EVMScriptExecutor. Can be called only by Admin of Easy Track.

Events:

```solidity=
emit EVMScriptExecutorChanged(address indexed _evmScriptExecutor)
```

#### function pause() external whenNotPaused onlyRole(PAUSE_ROLE)

Pauses Easy Track if it isn't paused. Paused Easy Track can't create and enact motions. Can be called only by address with granted `PAUSE_ROLE`.

#### function unpause() external whenPaused onlyRole(UNPAUSE_ROLE)

Unpauses Easy Track if it is paused. Can be called only by address with granted `UNPAUSE_ROLE`.

#### function getMotions() external view returns (Motion[] memory)

Returns list of motions not enacted and not canceled yet.

#### function getMotion(uint256 \_motionId) external view returns (Motion memory)

Returns motion with the given id.

#### function canObjectToMotion(uint256 \_motionId, address \_objector) external view returns (bool)

Returns if an `_objector` can submit an objection to motion with id equals to `_motionId` or not.

## EVMScriptExecutor

Contains method to execute EVMScripts. EVMScript uses format of Aragon's [CallsScript](https://github.com/aragon/aragonOS/blob/next/contracts/evmscript/executors/CallsScript.sol) executor. The next grammar describes EVMScript:

```
EVM_SCRIPT       -> SPEC_ID | SPEC_ID EVM_SCRIPTS_LIST
EVM_SCRIPTS_LIST -> EVM_SCRIPT_ITEM | EVM_SCRIPTS_LIST
EVM_SCRIPT_ITEM  -> ADDRESS CALL_DATA_LENGTH CALL_DATA
SPEC_ID          -> uint32
ADDRESS          -> address
CALL_DATA_LENGTH -> uint32
CALL_DATA        -> bytes of length CALL_DATA_LENGTH
```

### Methods

#### function executeEVMScript(bytes memory \_evmScript) external returns (bytes memory)

Executes passed EVMScripts and returns empty bytes as a result. Current realization uses deployed contract of Aragon's default [CallsScript.sol](https://github.com/aragon/aragonOS/blob/next/contracts/evmscript/executors/CallsScript.sol) executor. `EVMScriptExecutor.executeEVMScript` makes delegate call to `CallsScript.execScript` and returns the result of its execution(`CallsScript` always returns empty byte array on success) if the call was successful or reverts with error forwarded from `CallsScript.execScript` in other cases.

## IEVMScriptFactory

Interface which every EVMScript factory used in EasyTrack contract has to implement.

### Methods

#### function createEVMScript(address \_creator, bytes \_evmScriptCallData) external returns (bytes)

Creates new EVM Script using passed arguments. The method might apply validations or checks before creation and reverts with an error if some requirements weren't satisfied. EasyTrack contract uses `msg.sender` as value for `_creator` argument when called in create method, and `motion.creator` value when called in enact method.

# EVM Script Factories

At this moment Easy Track has next EVMScript factories:

- [IncreaseNodeOperatorStakingLimit]()
- [TopUpLegoProgram]()
- [TopUpRewarProgram]()
- [AddRewardProgram]()
- [RemoveRewardProgram]()

## IncreaseNodeOperatorStakingLimit

Creates EVM Script to increase staking limit for node operator with the given id. Only node operators registered in NodeOperatorsRegistry might create motions with this EVMScript factory.

### Methods

#### function createEVMScript(address \_creator, bytes \_evmScriptCallData) external view returns (bytes)

Creates EVM Script to increase node operators staking limit. `_evmScriptCallData` has to contain encoded tuple: `(uint256 _nodeOperatorId, uint256 _stakingLimit)`, where `_nodeOperatorId` - id of node operator in [NodeOperatorsRegistry](), `_stakingLimit` - new staking limit
To successfully create EVMScript next requirements must be met:

- Reward address of the node operator must be equal to the address of the `_creator`
- Node Operator must be not disabled.
- New staking limit must be greater than the current staking limit
- Total amount of signing keys must be less or equal to the new staking limit

#### function decodeEVMScriptCallData(bytes \_evmScriptCallData) external returns (uint256 \_nodeOperatorId, uint256 \_stakingLimit)

Decodes `_evmScriptCallData` into tuple `(uint256 _nodeOperatorId, uint256 _stakingLimit)`.

## TopUpLegoProgram

Creates EVMScript to top up the address of the LEGO program. Allows making transfers of ERC20 tokens and ETH. Only `trustedCaller` address can create motions with this EVMScript factory.

### Methods

#### function createEVMScript(address \_creator, bytes \_evmScriptCallData) external view returns (bytes)

Creates EVMScript to make new immediate payments to LEGO program address. `_evmScriptCallData` contains encoded tuple: `(address[] _rewardTokens, uint256[] _amounts)`, where `_rewardTokens` - addresses of ERC20 tokens (zero address for ETH) to transfer, `_amounts` - corresponding amount of tokens to transfer. To successfully create EVMScript next requirements must be met:

- `_creator` must be equal to `trustedCaller` address
- `_rewardTokens` and `_amounts` have same length
- `_rewardTokens` and `_amounts` are not empty
- `_amounts` has no zero values

#### function decodeEVMScriptCallData(bytes \_evmScriptCallData) external returns (address[] rewardTokens, uint256[] amounts)

Decodes `_evmScriptCallData` into tuple `(address[] rewardTokens, uint256[] amounts)`.

## TopUpRewardPrograms

Creates EVMScript to top up balances of reward programs. Transfers allowed only to the restricted list of addresses. To control the whitelist of allowed addresses of reward programs, `TopUpRewardPrograms` uses the contract `RewardProgramsRegistry`, which stores addresses of reward programs. Only `trustedCaller` address can create motions with this EVMScript factory.

### Methods

#### function createEVMScript(address \_creator, bytes \_evmScriptCallData) external view returns (bytes)

Creates EVM Script to make new immediate payments to list of reward programs. `_evmScriptCallData` contains encoded tuple: `(address[] _rewardPrograms, uint256[] _amounts[])`, where `_rewardPrograms` - addresses of reward programs to top up, `_amounts` - corresponding amount of transfer. To successfully create EVMScript next requirements must be met:

- `_creator` must be equal to `trustedCaller` address
- `_rewardPrograms` and `_amounts` have same length
- `_rewardPrograms` and `_amounts` are not empty
- `_amounts` has no zero values
- each address in `_rewardPrograms` listed in `RewardProgramsRegistry` as valid reward program

#### function decodeEVMScriptCallData(bytes \_evmScriptCallData) external returns (address[] rewardPrograms, uint256[] amounts)

Decodes `_evmScriptCallData` into tuple `(address[] rewardPrograms, uint256[] amounts)`.

## AddRewardProgram

Creates EVM Script to add new reward program address to `RewardProgramsRegistry`. Only `trustedCaller` address can create motions with this EVMScript factory.

### Methods

#### function createEVMScript(address \_creator, bytes \_evmScriptCallData) external view returns (bytes)

Creates EVM Script to add new reward address to `RewardProgramsRegistry`. `_evmScriptCallData` contains encoded tuple: `(address _rewardProgram)`, where `_rewardProgram` - new reward address to add. To successfully create EVMScript next requirements must be met:

- `_creator` must be equal to `trustedCaller` address
- `_rewardProgram` address hasn't be added in `RewardProgramsRegistry` earlier.

#### function decodeEVMScriptCallData(bytes \_evmScriptCallData) external returns (address \_rewardProgram)

Decodes `_evmScriptCallData` into tuple `(address _rewardProgram)`.

## RemoveRewardProgram

Creates EVM Script to remove reward program from `RewardPrgoramsRegistry`. Only `trustedCaller` address can create motions with this EVMScript factory.

### Methods

#### function createEVMScript(address \_creator, bytes \_evmScriptCallData) external view returns (bytes)

Creates EVM Script to remove reward program from `RewardProgramsRegistry`. `_evmScriptCallData` contains encoded tuple: `(address _rewardProgram)`, where `_rewardProgram` - reward address to remove. To successfully create EVMScript next requirements must be met:

- `_creator` must be equal to `trustedCaller` address
- `_rewardProgram` address must be listed in `RewardProgramsRegistry`.

#### function decodeEVMScriptCallData(bytes \_evmScriptCallData) external returns (address \_rewardProgram)

Decodes `_evmScriptCallData` into tuple `(address _rewardProgram)`.

# Additional Contracts

## RewardProgramsRegistry

Stores list of addresses with reward programs. TopUpRewardsProgram EVMScript factory allows transfers only to addresses listed in RewardProgramsRegistry.

### Methods

#### addRewardProgram(address \_rewardProgram) external

Adds reward program address to RewardProgramsRegistry, if it hasn't added yet, throws `"REWARD_PROGRAM_ALREADY_ADDED"` in other cases. Might be called only by EVMScriptExecutor contract.

#### removeRewardProgram(address \_rewardProgram) external

Removes reward program address from RewardProgramsRegistry. Throws `"REWARD_PROGRAM_NOT_FOUND"` if program address not in array. Might be called only by EVMScriptExecutor contract.

#### isRewardProgram(address \_rewardProgram) external view (returns bool)

Shows if address is whitelisted in RewardProgramsRegistry.

#### getRewardPrograms() external view returns (address[])

Returns list of whitelisted reward programs

## TrustedCaller

Helper contract contains logic to validate that only a trusted caller has access to certain methods. Might be inherited by other contracts to reduce the amount of redundant code.

### Storage Variables

```solidity=
address trustedCaller;
```

### Modifiers

#### modifier onlyTrustedCaller(address \_caller)

Compares the passed `_caller` value to the current `trustedCaller` value and throws `"CALLER_IS_FORBIDDEN"` in case addresses do not match.
