# -*- mode: org; fill-column: 60; -*-
#+STARTUP: showall indent hidestars

* Intro

Предложение считается принятым, если оно подано претендентом
с определенной ролью и не было получено никаких возражений.

Для каждого EasyTrack процесса существуют свои ограничения
на подачу предложений. В остальном, процесс практически
общий. Поэтому, чтобы сгенерировать все треки, я просто
скомпоную их из общих и специфичных фрагментов.

Tracks variants:
- validators requests
- grant distibution
- payments of rewards
- regular insurance payments

* Vote initiation

Чтобы начать голосование easy-track, необходимо вызвать
функцию start_vote. Она в свою очередь вызовет ~check_creds~
чтобы проверить, может ли ~msg.sender~ начинать голосование.

~check_creds~-функции свои для каждого easy-track.

[TODO:gmm] - Минимальное время между попытками одного
пользователя создать новое голосоваине

[TODO:gmm] - Минимальный порог для начала голосования

[TODO:gmm] - Нужно лочить токены, чтобы одними и теми же
токенами нельзя было создавать голосования слишком часто

#+NAME: start_vote
#+BEGIN_SRC vyper
  # Starting vote process
  @external
  def start_vote():
      # Check
      check_creds()
#+END_SRC

** Check credentials to start vote

Для каждого трека способ проверки прав для начала
голосования свой

*** validator request

Тот кто хочет начать голосование должен быть
валидатором. Допустим, мы ведем хеш-таблицу валидаторов,
тогда нужна роль, которая может добавлять и удалять
валидаторов и соответствующие функции

#+NAME: check_creds_validator_request
#+BEGIN_SRC vyper
  # Defining a validator's map
  validators: HashMap[uint256, bool]

  # Check for validator
  @internal
  def check_creds():
      assert validators(msg.sender), "not a validator"

  # Defining a admins's map
  admins: HashMap[uint256, bool]

  # Init admins
  def init_admins():
      # assert TODO: только при старте, добавляем админа?

  # Add validator
  def add_validator(param):
      assert admins(msg.sender), "not a admin"
      validators[param] = true

  # Del validator
  def del_validator
      assert admins(msg.sender), "not a admin"
      validators[param] = false
#+END_SRC

*** grant distibution

Голосование начинается, если удовлетворены требования
пороговой подписи K из N ([TODO:gmm]я пока не знаю как это
правильно написать)

*** payments of rewards

[TODO:gmm] Как я понимаю, эти пэйменты будет вызывать арагон-агент. Как
он будет это делать?

*** regular insurance payments

[TODO:gmm] Тут надо делать периодический вызов?


* Objections

** Avoidance of malicious objections

Существует атака, при которой возражающий может продать
проголосовавшие жетоны и сразу же купить новые, чтобы
проголосовать снова. Чтобы этого не произошло, в контракте
easy-track необходимо обратиться к менеджеру токенов, чтобы
запретить передачу этих токенов до конца голосования.

Еще более экономичный способ - использовать остатки на
момент блока, в котором началось голосование. То есть
голосовать могут только жетоны, которые не были перемещены с
момента начала голосования.

** Send objection function

[TODO:gmm] send_objection fun

[TODO:gmm] проверка не истекло ли время голосования

#+NAME: send_objection
#+BEGIN_SRC vyper
  # Starting vote process
  @external
  def send_objection():
#+END_SRC

* Expiration of the voting period

[TODO:gmm] - Как я могу получить время, чтобы определить что
голосование пора завершать?

[TODO:gmm] - Если я завершил голосование, то здесь нужен
event?

[TODO:gmm] - Подсчет возражений

[TODO:gmm] - Как мне запустить что-то по результатам?

** Objection threshold

[TODO:gmm] Нужен свой порог для каждого трека

* Monitoring of voting

[TODO:gmm] - Как это делать?
