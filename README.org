# -*- mode: org; fill-column: 60; -*-
#+STARTUP: showall indent hidestars

* Intro

У нас есть 4 трека, каждый из них может одновременно вести
несколько голосований.

Я пока не придумал ничего лучше, чем положить все
настраиваемые параметры в структуру голосования.

По сути треки отличаются только базовыми настройками этих
голосований. Мы можем сделать их отдельными контрактами.

Для всех голосований предложение считается принятым, если до
его окончания не было получено достаточно возражений.

Tracks variants:
- validators requests
- grant distibution
- payments of rewards
- regular insurance payments

* Init

Переменная для хранения ~owner~-а

#+BEGIN_SRC vyper :noweb-ref data
  owner: public(address)
#+END_SRC

При инициализации запоминаем, кто ~owner~:

#+BEGIN_SRC vyper :noweb-ref init
  self.owner = msg.sender
#+END_SRC

Init нужен чтобы определить, кто может добавлять тех, кому
разрешено начинать голосование. По идее, только контракт
всеобщего голосования DAO может сделать это. Но, насколько я
понял, мы избегаем апгрейда DAO-контрактов, поэтому пока
рулит всем ~owner~.

[TODO:gmm] - Разобраться, как можно интегрироваться со
всеобщим голосованием DAO

* Ownership

Проверка ~onlyOwner~:

#+NAME: only_owner
#+BEGIN_SRC vyper
  assert msg.sender == self.owner
#+END_SRC

Надо уметь трансферить ~owner~-а:

#+NAME: transfer_ownership
#+BEGIN_SRC vyper :noweb yes
  @external
  def transferOwnership(_new_owner: address):
      <<only_owner>>
      self.owner = _new_owner
#+END_SRC

* Ballot Makers

Только "узкий круг ограниченных людей" может начинать
голосования. Храним их в мапе:

#+BEGIN_SRC vyper :noweb-ref data
  ballot_makers: public(HashMap[address, bool])
#+END_SRC

Проверка, что ~ballot maker~ относится к этому кругу людей:

#+NAME: only_ballot_maker
#+BEGIN_SRC vyper
  assert self.ballot_makers[msg.sender] == True
#+END_SRC

~Owner~ может добавлять и удалять ~ballot makers~:

#+NAME: add_ballot_maker
#+BEGIN_SRC vyper :noweb yes
  @external
  def add_ballot_maker(_param: address):
      <<only_owner>>
      self.ballot_makers[_param] = True
#+END_SRC

#+NAME: del_ballot_maker
#+BEGIN_SRC vyper :noweb yes
  @external
  def del_ballot_maker(_param: address):
      <<only_owner>>
      self.ballot_makers[_param] = False
#+END_SRC

* Ballot Time

Мы считаем голосование завершенным, если одно из условий

Мы считаем голосование завершенным, если одно из условий
истинно:
- текущее время блока больше чем значение поля deadline
- вес возражений выше порога возражений

Для этого нам нужны соответствующие поля в структуре
голосования:

#+BEGIN_SRC vyper :noweb-ref struct_ballot
  deadline: uint256
  objections_total_weight: uint256
#+END_SRC

И функция, которая проверят, завершено ли голосование

#+NAME: is_ballot_finished
#+BEGIN_SRC vyper
  # @external
  # def is_ballot_finished(_ballot_id: uint256) -> bool:
  #     if ( block.timestamp > self.ballots[_ballot_id].deadline ):
  #        return True
  #     if ( objections_threshold > ballots[_ballot_id].objections_total_weight ):
  #        return True
  #     return False
#+END_SRC

Для разных треков может быть разное время голосования,
поэтому нужно поле для хранения установленного времени:

#+BEGIN_SRC vyper :noweb-ref data
  ballot_time: public(uint256)
#+END_SRC

Будем инициализировать это поле при иницализации контракта:

#+BEGIN_SRC vyper :noweb-ref init
  self.ballot_time = _ballot_time
#+END_SRC

из соответствующего параметра:

#+BEGIN_SRC vyper :noweb-ref init_params
  _ballot_time: uint256,
#+END_SRC

* Make Ballot

Возможна атака, когда ~ballot maker~ создает много
голосований, в рассчете на то, у возражающих не хватит
стейка чтобы возразить по всем голосованиям и какая-то часть
голосований пройдет без возражений. Например, так можно
выводить деньги на грантовые программы. Даже если гранты
переводятся на мультисиг, это требует только договоренности
с владельцами мультисига, которые тоже могут иметь
заинтересованность в выводе денег.

Была идея, чтобы возможность создавать easy-track
голосования была как-то привязана к LDO-токенам.

Мы могли бы заблокировать токены двумя способами:
- перевести их на контракт, и после окончания голосования
  дать возможность забрать
- запретить их трансфер на время голосования, вызвав
  токен-менеджер (требует апгрейда токен-менеджера)

(Токен-менеджер - это контракт, который позволяет увидеть
сколько у адреса токенов, которые он пока не может
трансферить из-за вестинга. Смотреть тут:
https://github.com/aragon/aragon-apps/tree/master/apps/token-manager/contracts)

Мы не хотим апгрейдить токен-менеджер, т.к. это требует
много телодвижений с аудитом и вообще это непросто. Но если
мы захотим это делать, то можем включить нужный функционал в
другие изменения.

Еще один аспект, как минимум, по validator's easy-track:
адрес, на котором валидаторы хотят работать с изи-треком не
обязан совпадать с адресом на котором они держать
LDO-токены. Также, так как валидаторы добавляются ~owner~-ом
то им не нужен минимальный стейк для создания голосования.

Таким образом, мы контролируем тех, кто создает голосование,
и если начинается спам - оперативно удаляем его. Поэтому
дополнительные механизмы связанные с LDO-токенами не
нужны. [TODO:gmm] - Но нужен механизм отмены спаммерских
голосований тогда.


Голосования нумеруются начиная с единицы, текущенной номер
хранится в соотвествующей переменной:

#+BEGIN_SRC vyper :noweb-ref data
  next_ballot_index: public(uint256)
#+END_SRC

Она должна быть проинициализирована, когда контракт
создается:

#+BEGIN_SRC vyper :noweb-ref init
  self.next_ballot_index = 1
#+END_SRC

[TODO:gmm] - Возможно нужно минимальное время между
попытками одного пользователя создать новое голосование?

Функция создания голосования:

#+NAME: make_ballot
#+BEGIN_SRC vyper :noweb yes
  @external
  def make_ballot(_ballotHash: bytes32):
      <<only_ballot_maker>>
      self.ballots[self.next_ballot_index] = Ballot({
          deadline: block.timestamp + self.ballot_time,
          objections_total_weight: 0,
          ballot_maker: msg.sender,
          snapshot_block: block.number - 1
      })
      <<set_snapshot_block>>
      self.next_ballot_index = self.next_ballot_index + 1
#+END_SRC

Для нее в структуре голосования нам нужны поля:

#+BEGIN_SRC vyper :noweb-ref struct_ballot
  ballot_maker: address
#+END_SRC

[TODO:gmm] - Для validator's easy track мы хотим проверять,
что адрес, который создает голосование есть в Node Operator
Registry. См. строчку 273 в файле:
https://github.com/lidofinance/lido-dao/blob/master/contracts/0.4.24/nos/NodeOperatorsRegistry.sol

#+BEGIN_EXAMPLE solidity
  require(msg.sender == operators[_operator_id].rewardAddress, "APP_AUTH_FAILED");
#+END_EXAMPLE

Тут мы должны будем передавать operator_id в функцию
создания голосования. Мапа operators объявлена как internal,
но есть функция getNodeOperator которая view accessor для
этой мапы, и [TODO:gmm] - ее можно заюзать через интерфейс.

* Send objection

Возможна атака, при которой возражающий может продать
проголосовавшие жетоны и сразу же купить новые, чтобы
проголосовать снова. Это не бесплатная атака, учитывая цену
газа. В случае ее реализации DAO переходит к полноценному
голосованию по всем вопросам. Мы считаем риск небольшим и
сейчас ничего не делаем с этой угрозой.

[TODO:gmm] - Можно смотреть снапшот баланса токенов так:

#+BEGIN_EXAMPLE solidity
  import "@aragon/minime/contracts/MiniMeToken.sol";
  uint64  snapshotBlock = getBlockNumber64() - 1;
  uint256 votingPower = token.totalSupplyAt(snapshotBlock);
#+END_EXAMPLE

Мы можем взять текущий блок минус один, и записать его в
структуру Ballot. Когда кто-то хочет проголосовать против,
мы можем узнать его баланс на момент этого блока и так
определить его power.

Нам потребуется импортировать интерфейс MiniMe token-а отсюда:
https://github.com/aragon/minime/blob/master/contracts/MiniMeToken.sol

#+BEGIN_SRC vyper :noweb-ref imports
  from vyper.interfaces import ERC20
#+END_SRC

#+BEGIN_SRC vyper :noweb-ref interfaces
  interface MiniMe:
    def balanceOfAt(_owner: address, _blockNumber: uint256) -> uint256: view
#+END_SRC

Нужна также переменная, где лежит адрес LDO-контракта

#+BEGIN_SRC vyper :noweb-ref data
  TOKEN: constant(address) = 0x5A98FcBEA516Cf06857215779Fd812CA3beF1B32
#+END_SRC

Тут будем хранить блок, на который считаем балансы

#+BEGIN_SRC vyper :noweb-ref struct_ballot
  snapshot_block: uint256
#+END_SRC

При создании голосования надо заполнить это поле:

#+BEGIN_SRC vyper :noweb-ref set_snapshot_block
  self.ballots[self.next_ballot_index].snapshot_block = block.number - 1
#+END_SRC

Проверка не истекло ли время голосования.

#+NAME: only_active
#+BEGIN_SRC vyper
  assert block.timestamp < self.ballots[_ballot_idx].deadline
#+END_SRC

Порог возражений:

#+BEGIN_SRC vyper :noweb-ref data
  objections_threshold: public(uint256)
#+END_SRC

Инициализация порога возражений в init

#+BEGIN_SRC vyper :noweb-ref init_params
  _objections_threshold: uint256,
#+END_SRC

#+BEGIN_SRC vyper :noweb-ref init
  self.objections_threshold = _objections_threshold
#+END_SRC


Проверка, достаточно ли уже возражений

#+NAME: objections_not_enough
#+BEGIN_SRC vyper
  assert self.ballots[_ballot_idx].objections_total_weight < self.objections_threshold
#+END_SRC

Функция возражения, работает только до дедлайна и пока
возражений недостаточно:

[TODO:gmm] - Надо считать в процентах от totalSupplyAt но
это чуть дороже по газу. "Objections_threshold должен быть в
процентах от voting power, а не абсолютное число. потому что
total voting power будет меняться во времени" (с) Sam

#+NAME: send_objection
#+BEGIN_SRC vyper :noweb yes
  @external
  def sendObjection(_ballot_idx: uint256):
      <<only_active>>
      <<objections_not_enough>>
      _voting_power: uint256 = MiniMe(TOKEN).balanceOfAt(msg.sender, self.ballots[_ballot_idx].snapshot_block)
      self.objections[_ballot_idx][msg.sender] = _voting_power
      self.ballots[_ballot_idx].objections_total_weight = _voting_power + self.ballots[_ballot_idx].objections_total_weight
      log Objection(msg.sender, _voting_power)
#+END_SRC

Мы не можем иметь мапу в структуре голосования, которая
хранит возражения, поэтому их придется хранить отдельнно в
storage переменной:

#+BEGIN_SRC vyper :noweb-ref data
  objections: HashMap[uint256, HashMap[address, uint256]]
#+END_SRC

Не забудем объявить event:

#+BEGIN_SRC vyper :noweb-ref events
  event Objection:
    sender: indexed(address)
    power: uint256
#+END_SRC

[TODO:gmm] SafeMath нужно как-то объявлять?

[TODO:gmm] Если нельзя иметь HashMap в структуре, то можно в
отдельной переменной сделать HashMap от HashMap-а

[TODO:gmm] Посмотреть что такое allowance и permit
(подписанные сообщения разрешающие тратить) в контексте
траты токенов

[TODO:gmm] Возможно айди голосования лучше сделать общим для
всех треков через наследование или базовый контракт - factory

[TODO:gmm] Внимательно прочесть MiniMi-контракт, объявить
его интерфейс, приводить к нему и заюзать

* Ballot

Голосования лежат в мапе, где ключ - индекс голосования, а
значение - структура голосования:

#+BEGIN_SRC vyper :noweb-ref data
  ballots: public(HashMap[uint256, Ballot])
#+END_SRC

#+BEGIN_SRC vyper :noweb-ref structs :noweb yes
  struct Ballot:
    <<struct_ballot>>
#+END_SRC

* Ballot Endings

Считаем, что у нас есть функция, которую можно вызвать, и
она сработает, если время голосования прошло, а возражений
поступило недостаточно.

[TODO:gmm] - Как задавать эту функцию коссвенно? В новом
оракуле есть кусок, который позволяет зашивать проивольный
смарт-контракт и дергать его - посмотреть как это
сделано. Надо вызвать функцию, которая переведет
деньги. Читать как сделано в арагоне. В LIDO DAO есть адреса
арагоновских проксиков, в арагоне написано как это работает
(etherscan). CallData определяет что именно дергать. Также
посмотреть как у арагона это сделано? Посмотреть что
происходит при enacting голосования арагона в LIDO DAO, и в
код арагона на etherscan

#+NAME: ballot_result
#+BEGIN_SRC vyper :noweb yes
  @external
  def ballotResult(_ballot_idx: uint256):
      assert block.timestamp > self.ballots[_ballot_idx].deadline
      <<objections_not_enough>>
      log EnactBallot(_ballot_idx)
#+END_SRC

Если голосование завершено, то здесь нужен event:

#+BEGIN_SRC vyper :noweb-ref events
  event EnactBallot:
    idx: indexed(uint256)
#+END_SRC



* Other task and todoes

[TODO:gmm] - там ещё нужно реализовать ограничение списка
инициаторов голосования через обращение к
NodeOperatorsRegistry, а не локальный массив, как мы с тобой
обсуждали в звонке (c) Sam

[TODO:gmm] - В ldo-purchase-executor/script/deploy.py есть
функция deploy_and_start_dao_vote надо посмотреть можно по
ней что-то понять. Там же есть про деполой контракта и как
проголосовать (отправить возражение) в dao_voting.vote()
есть что-то что вероятно поможет написать тесты.

[TODO:gmm] - Кроме покупки страховки команда Meter
выкатывала одно голосование за 4 разные вещи -
посмотреть. Можно оттуда скопипастить.

[TODO:gmm] - Как мне представиться контрактом голосования
DAO, чтобы протестить это? Как написать такой тест? Как-то
так?

#+BEGIN_SRC vyper
  # Lido DAO Vote contract
  interface DaoVote:
      def someFunc(_someparam: someType):
      ...
#+END_SRC

[TODO:gmm] grant distibution - Голосование начинается, если
удовлетворены требования пороговой подписи K из N

[TODO:gmm] regular insurance payments Тут надо делать вызов
вручную раз в полгода

[TODO:gmm] - Upgradable contract?

* Tangle

#+BEGIN_SRC vyper :noweb yes :tangle ./contracts/ValidatorsVote.vy
    # @version 0.2.8
    # @author Lido <info@lido.fi>
    # @licence MIT
    <<imports>>

    <<interfaces>>

    <<events>>

    <<structs>>

    <<data>>

    @external
    def __init__(
        <<init_params>>
        _stub: bool
        ):
        <<init>>

    <<transfer_ownership>>

    <<add_ballot_maker>>

    <<del_ballot_maker>>

    <<make_ballot>>

    <<is_ballot_finished>>

    <<withdraw_ballot_stake>>

    <<send_objection>>

    <<ballot_result>>
#+END_SRC

* Tests

Это заготовки для тестов.

Когда я делаю тест я хочу:
- развернуть изи-трек
- создать голосование
- закинуть возражение
- завершить голосование (как ускорить его?)
- посчитать результаты
- убедиться, что посчитано верно

Нужны приемочные тесты (сценарии):
- что изи-трек разворачивается
- что голосование создается
- что голосование реагирует на возражения
- что оно завершается (промотать время brownie test time
  прямо из теста)

#+BEGIN_SRC python :noweb yes :tangle ./tests/conftest.py :exports none
  import pytest
  from brownie import chain, Wei, ZERO_ADDRESS

  from scripts.deploy import deploy_and_start_dao_vote

  from utils.config import (
      ldo_token_address,
      lido_dao_acl_address,
      lido_dao_agent_address,
      lido_dao_voting_address,
      lido_dao_token_manager_address
  )


  @pytest.fixture(scope="function", autouse=True)
  def shared_setup(fn_isolation):
      pass


  @pytest.fixture(scope='module')
  def ldo_holder(accounts):
      return accounts.at('0xAD4f7415407B83a081A0Bee22D05A8FDC18B42da', force=True)


  @pytest.fixture(scope='module')
  def dao_acl(interface):
      return interface.ACL(lido_dao_acl_address)


  @pytest.fixture(scope='module')
  def dao_voting(interface):
      return interface.Voting(lido_dao_voting_address)


  @pytest.fixture(scope='module')
  def dao_token_manager(interface):
      return interface.TokenManager(lido_dao_token_manager_address)


  # Lido DAO Agent app
  @pytest.fixture(scope='module')
  def dao_agent(interface):
      return interface.Agent(lido_dao_agent_address)


  @pytest.fixture(scope='module')
  def ldo_token(interface):
      return interface.ERC20(ldo_token_address)


  class Helpers:
      eth_banker = None

      @staticmethod
      def fund_with_eth(addr, amount = '1000 ether'):
          Helpers.eth_banker.transfer(to=addr, amount=amount)

      @staticmethod
      def filter_events_from(addr, events):
        return list(filter(lambda evt: evt.address == addr, events))

      @staticmethod
      def assert_single_event_named(evt_name, tx, evt_keys_dict = None):
        receiver_events = Helpers.filter_events_from(tx.receiver, tx.events[evt_name])
        assert len(receiver_events) == 1
        if evt_keys_dict is not None:
          assert dict(receiver_events[0]) == evt_keys_dict
        return receiver_events[0]


  @pytest.fixture(scope='module')
  def helpers(accounts):
      Helpers.eth_banker = accounts.at('0xBE0eB53F46cd790Cd13851d5EFf43D12404d33E8', force=True)
      return Helpers


  @pytest.fixture(scope='module')
  def deploy_executor_and_pass_dao_vote(accounts, ldo_holder, ldo_token, dao_acl, dao_voting, dao_token_manager):
      def deploy(
          eth_to_ldo_rate,
          vesting_cliff_delay,
          vesting_end_delay,
          offer_expiration_delay,
          ldo_purchasers,
          allocations_total
      ):
          (executor, vote_id) = deploy_and_start_dao_vote(
              {'from': ldo_holder},
              eth_to_ldo_rate=eth_to_ldo_rate,
              vesting_cliff_delay=vesting_cliff_delay,
              vesting_end_delay=vesting_end_delay,
              offer_expiration_delay=offer_expiration_delay,
              ldo_purchasers=ldo_purchasers,
              allocations_total=allocations_total
          )

          print(f'vote id: {vote_id}')

          # together these accounts hold 15% of LDO total supply
          ldo_holders = [
              '0x3e40d73eb977dc6a537af587d48316fee66e9c8c',
              '0xb8d83908aab38a159f3da47a59d84db8e1838712',
              '0xa2dfc431297aee387c05beef507e5335e684fbcd'
          ]

          for holder_addr in ldo_holders:
              print('voting from acct:', holder_addr)
              accounts[0].transfer(holder_addr, '0.1 ether')
              account = accounts.at(holder_addr, force=True)
              dao_voting.vote(vote_id, True, False, {'from': account})

          # wait for the vote to end
          chain.sleep(3 * 60 * 60 * 24)
          chain.mine()

          assert dao_voting.canExecute(vote_id)
          dao_voting.executeVote(vote_id, {'from': accounts[0]})

          print(f'vote executed')

          total_ldo_assignment = sum([ p[1] for p in ldo_purchasers ])
          assert ldo_token.balanceOf(executor) == total_ldo_assignment

          ldo_assign_role = dao_token_manager.ASSIGN_ROLE()
          assert dao_acl.hasPermission(executor, dao_token_manager, ldo_assign_role)

          return executor

      return deploy
#+END_SRC

#+BEGIN_SRC python :noweb yes :tangle ./tests/test_validators_vote.py :exports none
  import pytest
  from brownie import Wei, chain, reverts
  from brownie.network.state import Chain

  from purchase_config import ETH_TO_LDO_RATE_PRECISION

  LDO_ALLOCATIONS = [
      1_000 * 10**18,
      3_000_000 * 10**18,
      20_000_000 * 10**18
  ]

  # 100 LDO in one ETH
  ETH_TO_LDO_RATE = 100 * 10**18

  VESTING_CLIFF_DELAY = 1 * 60 * 60 * 24 * 365 # one year
  VESTING_END_DELAY = 2 * 60 * 60 * 24 * 365 # two years
  OFFER_EXPIRATION_DELAY = 2629746 # one month


  @pytest.fixture(scope='function')
  def executor(accounts, deploy_executor_and_pass_dao_vote):
      return deploy_executor_and_pass_dao_vote(
          eth_to_ldo_rate=ETH_TO_LDO_RATE,
          vesting_cliff_delay=VESTING_CLIFF_DELAY,
          vesting_end_delay=VESTING_END_DELAY,
          offer_expiration_delay=OFFER_EXPIRATION_DELAY,
          ldo_purchasers=[ (accounts[i], LDO_ALLOCATIONS[i]) for i in range(0, len(LDO_ALLOCATIONS)) ],
          allocations_total=sum(LDO_ALLOCATIONS)
      )


  def test_deploy_should_fails_on_wrong_allocations_total(accounts, deploy_executor_and_pass_dao_vote):
      with reverts():
          deploy_executor_and_pass_dao_vote(
              eth_to_ldo_rate=ETH_TO_LDO_RATE,
              vesting_cliff_delay=VESTING_CLIFF_DELAY,
              vesting_end_delay=VESTING_END_DELAY,
              offer_expiration_delay=OFFER_EXPIRATION_DELAY,
              ldo_purchasers=[ (accounts[i], LDO_ALLOCATIONS[i]) for i in range(0, len(LDO_ALLOCATIONS)) ],
              allocations_total=sum(LDO_ALLOCATIONS) + 1
          )


  def test_deploy_should_fails_on_zero_rate(accounts, deploy_executor_and_pass_dao_vote):
      with reverts():
          deploy_executor_and_pass_dao_vote(
              eth_to_ldo_rate=0,
              vesting_cliff_delay=VESTING_CLIFF_DELAY,
              vesting_end_delay=VESTING_END_DELAY,
              offer_expiration_delay=OFFER_EXPIRATION_DELAY,
              ldo_purchasers=[ (accounts[i], LDO_ALLOCATIONS[i]) for i in range(0, len(LDO_ALLOCATIONS)) ],
              allocations_total=sum(LDO_ALLOCATIONS)
          )


  def test_deploy_should_fails_on_vesting_ends_before_cliff(accounts, deploy_executor_and_pass_dao_vote):
      with reverts():
          deploy_executor_and_pass_dao_vote(
              eth_to_ldo_rate=ETH_TO_LDO_RATE,
              vesting_cliff_delay=VESTING_CLIFF_DELAY,
              vesting_end_delay=VESTING_CLIFF_DELAY - 1,
              offer_expiration_delay=OFFER_EXPIRATION_DELAY,
              ldo_purchasers=[ (accounts[i], LDO_ALLOCATIONS[i]) for i in range(0, len(LDO_ALLOCATIONS)) ],
              allocations_total=sum(LDO_ALLOCATIONS)
          )


  def test_deploy_should_fails_on_zero_offer_exparation_delay(accounts, deploy_executor_and_pass_dao_vote):
      with reverts():
          deploy_executor_and_pass_dao_vote(
              eth_to_ldo_rate=ETH_TO_LDO_RATE,
              vesting_cliff_delay=VESTING_CLIFF_DELAY,
              vesting_end_delay=VESTING_END_DELAY,
              offer_expiration_delay=0,
              ldo_purchasers=[ (accounts[i], LDO_ALLOCATIONS[i]) for i in range(0, len(LDO_ALLOCATIONS)) ],
              allocations_total=sum(LDO_ALLOCATIONS)
          )


  def test_deploy_should_fails_on_purchasers_duplicates(accounts, deploy_executor_and_pass_dao_vote):
      with reverts():
          deploy_executor_and_pass_dao_vote(
              eth_to_ldo_rate=ETH_TO_LDO_RATE,
              vesting_cliff_delay=VESTING_CLIFF_DELAY,
              vesting_end_delay=VESTING_END_DELAY,
              offer_expiration_delay=OFFER_EXPIRATION_DELAY,
              ldo_purchasers=[ (accounts[0], LDO_ALLOCATIONS[0]) for i in range(0, len(LDO_ALLOCATIONS)) ],
              allocations_total=sum(LDO_ALLOCATIONS)
          )


  def test_purchase_via_transfer(accounts, executor, dao_agent, helpers, ldo_token, dao_token_manager):
      purchaser = accounts.at(accounts[0], force=True)
      purchase_ldo_amount = LDO_ALLOCATIONS[0]

      eth_cost = purchase_ldo_amount * ETH_TO_LDO_RATE_PRECISION // ETH_TO_LDO_RATE

      allocation = executor.get_allocation(purchaser)
      assert allocation[0] == purchase_ldo_amount
      assert allocation[1] == eth_cost

      helpers.fund_with_eth(purchaser, eth_cost)

      dao_eth_balance_before = dao_agent.balance()

      tx = purchaser.transfer(to=executor, amount=eth_cost, gas_limit=400_000)
      purchase_evt = helpers.assert_single_event_named('PurchaseExecuted', tx)

      assert purchase_evt['ldo_receiver'] == purchaser
      assert purchase_evt['ldo_allocation'] == purchase_ldo_amount
      assert purchase_evt['eth_cost'] == eth_cost

      dao_eth_balance_increase = dao_agent.balance() - dao_eth_balance_before
      assert dao_eth_balance_increase == eth_cost
      assert ldo_token.balanceOf(purchaser) == purchase_ldo_amount

      vesting = dao_token_manager.getVesting(purchaser, purchase_evt['vesting_id'])

      assert vesting['amount'] == purchase_ldo_amount
      assert vesting['start'] == tx.timestamp
      assert vesting['cliff'] == tx.timestamp + VESTING_CLIFF_DELAY
      assert vesting['vesting'] == tx.timestamp + VESTING_END_DELAY
      assert vesting['revokable'] == False


  def test_purchase_via_execute_purchase(accounts, executor, dao_agent, helpers, ldo_token, dao_token_manager):
      purchaser = accounts.at(accounts[0], force=True)
      purchase_ldo_amount = LDO_ALLOCATIONS[0]

      eth_cost = purchase_ldo_amount * ETH_TO_LDO_RATE_PRECISION // ETH_TO_LDO_RATE

      allocation = executor.get_allocation(purchaser)
      assert allocation[0] == purchase_ldo_amount
      assert allocation[1] == eth_cost

      helpers.fund_with_eth(purchaser, eth_cost)

      dao_eth_balance_before = dao_agent.balance()

      tx = executor.execute_purchase(purchaser, { 'from': purchaser, 'value': eth_cost })
      purchase_evt = helpers.assert_single_event_named('PurchaseExecuted', tx)

      assert purchase_evt['ldo_receiver'] == purchaser
      assert purchase_evt['ldo_allocation'] == purchase_ldo_amount
      assert purchase_evt['eth_cost'] == eth_cost

      dao_eth_balance_increase = dao_agent.balance() - dao_eth_balance_before
      assert dao_eth_balance_increase == eth_cost
      assert ldo_token.balanceOf(purchaser) == purchase_ldo_amount

      vesting = dao_token_manager.getVesting(purchaser, purchase_evt['vesting_id'])

      assert vesting['amount'] == purchase_ldo_amount
      assert vesting['start'] == tx.timestamp
      assert vesting['cliff'] == tx.timestamp + VESTING_CLIFF_DELAY
      assert vesting['vesting'] == tx.timestamp + VESTING_END_DELAY
      assert vesting['revokable'] == False


  def test_stranger_not_allowed_to_purchase_via_execute_purchase(accounts, executor, helpers):
      purchase_ldo_amount = LDO_ALLOCATIONS[0]
      stranger = accounts.at(accounts[5], force=True)

      eth_cost = purchase_ldo_amount * ETH_TO_LDO_RATE_PRECISION // ETH_TO_LDO_RATE

      allocation = executor.get_allocation(stranger)
      assert allocation[0] == 0
      assert allocation[1] == 0

      helpers.fund_with_eth(stranger, eth_cost)

      with reverts("no allocation"):
          executor.execute_purchase(stranger, { 'from': stranger, 'value': eth_cost })


  def test_stranger_not_allowed_to_purchase_via_transfer(accounts, executor, helpers):
      purchase_ldo_amount = LDO_ALLOCATIONS[0]
      stranger = accounts.at(accounts[5], force=True)

      allocation = executor.get_allocation(stranger)
      assert allocation[0] == 0
      assert allocation[1] == 0

      eth_cost = purchase_ldo_amount * ETH_TO_LDO_RATE_PRECISION // ETH_TO_LDO_RATE

      helpers.fund_with_eth(stranger, eth_cost)

      with reverts("no allocation"):
          executor.execute_purchase(stranger, { 'from': stranger, 'value': eth_cost })


  def test_stranger_allowed_to_purchase_token_for_purchaser_via_execute_purchase(accounts, executor, dao_agent, helpers, ldo_token, dao_token_manager):
      purchaser = accounts.at(accounts[0], force=True)
      purchase_ldo_amount = LDO_ALLOCATIONS[0]
      stranger = accounts.at(accounts[5], force=True)

      eth_cost = purchase_ldo_amount * ETH_TO_LDO_RATE_PRECISION // ETH_TO_LDO_RATE

      allocation = executor.get_allocation(purchaser)
      assert allocation[0] == purchase_ldo_amount
      assert allocation[1] == eth_cost

      helpers.fund_with_eth(stranger, eth_cost)

      dao_eth_balance_before = dao_agent.balance()

      tx = executor.execute_purchase(purchaser, { 'from': stranger, 'value': eth_cost })
      purchase_evt = helpers.assert_single_event_named('PurchaseExecuted', tx)

      assert purchase_evt['ldo_receiver'] == purchaser
      assert purchase_evt['ldo_allocation'] == purchase_ldo_amount
      assert purchase_evt['eth_cost'] == eth_cost

      dao_eth_balance_increase = dao_agent.balance() - dao_eth_balance_before
      assert dao_eth_balance_increase == eth_cost
      assert ldo_token.balanceOf(purchaser) == purchase_ldo_amount

      vesting = dao_token_manager.getVesting(purchaser, purchase_evt['vesting_id'])

      assert vesting['amount'] == purchase_ldo_amount
      assert vesting['start'] == tx.timestamp
      assert vesting['cliff'] == tx.timestamp + VESTING_CLIFF_DELAY
      assert vesting['vesting'] == tx.timestamp + VESTING_END_DELAY
      assert vesting['revokable'] == False


  def test_purchase_via_transfer_not_allowed_with_insufficient_funds(accounts, executor, dao_agent, helpers):
      purchaser = accounts.at(accounts[0], force=True)
      purchase_ldo_amount = LDO_ALLOCATIONS[0]

      eth_cost = purchase_ldo_amount * ETH_TO_LDO_RATE_PRECISION // ETH_TO_LDO_RATE

      allocation = executor.get_allocation(purchaser)
      assert allocation[0] == purchase_ldo_amount
      assert allocation[1] == eth_cost

      eth_cost = eth_cost - 1e18

      helpers.fund_with_eth(purchaser, eth_cost)

      with reverts("insufficient funds"):
          purchaser.transfer(to=executor, amount=eth_cost, gas_limit=400_000)


  def test_purchase_via_execute_purchase_not_allowed_with_insufficient_funds(accounts, executor, helpers):
      purchaser = accounts.at(accounts[0], force=True)
      purchase_ldo_amount = LDO_ALLOCATIONS[0]

      eth_cost = purchase_ldo_amount * ETH_TO_LDO_RATE_PRECISION // ETH_TO_LDO_RATE

      allocation = executor.get_allocation(purchaser)
      assert allocation[0] == purchase_ldo_amount
      assert allocation[1] == eth_cost

      eth_cost = eth_cost - 1e18

      helpers.fund_with_eth(purchaser, eth_cost)

      with reverts("insufficient funds"):
          executor.execute_purchase(purchaser, { 'from': purchaser, 'value': eth_cost })


  def test_double_purchase_not_allowed_via_transfer(accounts, executor, helpers, ldo_token, dao_token_manager, dao_agent):
      purchaser = accounts.at(accounts[0], force=True)
      purchase_ldo_amount = LDO_ALLOCATIONS[0]

      eth_cost = purchase_ldo_amount * ETH_TO_LDO_RATE_PRECISION // ETH_TO_LDO_RATE

      allocation = executor.get_allocation(purchaser)
      assert allocation[0] == purchase_ldo_amount
      assert allocation[1] == eth_cost

      helpers.fund_with_eth(purchaser, eth_cost)

      dao_eth_balance_before = dao_agent.balance()

      tx = purchaser.transfer(to=executor, amount=eth_cost, gas_limit=400_000)
      purchase_evt = helpers.assert_single_event_named('PurchaseExecuted', tx)

      assert purchase_evt['ldo_receiver'] == purchaser
      assert purchase_evt['ldo_allocation'] == purchase_ldo_amount
      assert purchase_evt['eth_cost'] == eth_cost

      dao_eth_balance_increase = dao_agent.balance() - dao_eth_balance_before
      assert dao_eth_balance_increase == eth_cost
      assert ldo_token.balanceOf(purchaser) == purchase_ldo_amount

      with reverts("no allocation"):
          purchaser.transfer(to=executor, amount=eth_cost, gas_limit=400_000)


  def test_double_purchase_not_allowed_via_execute_purchase(accounts, executor, dao_agent, helpers, ldo_token):
      purchaser = accounts.at(accounts[0], force=True)
      purchase_ldo_amount = LDO_ALLOCATIONS[0]

      eth_cost = purchase_ldo_amount * ETH_TO_LDO_RATE_PRECISION // ETH_TO_LDO_RATE

      allocation = executor.get_allocation(purchaser)
      assert allocation[0] == purchase_ldo_amount
      assert allocation[1] == eth_cost

      helpers.fund_with_eth(purchaser, eth_cost)

      executor.execute_purchase(purchaser, { 'from': purchaser, 'value': eth_cost })

      with reverts("no allocation"):
          executor.execute_purchase(purchaser, { 'from': purchaser, 'value': eth_cost })


  def test_overpay_should_be_returned_via_transfer(accounts, executor, dao_agent, helpers, ldo_token):
      purchaser = accounts.at(accounts[0], force=True)
      purchase_ldo_amount = LDO_ALLOCATIONS[0]

      eth_cost = purchase_ldo_amount * ETH_TO_LDO_RATE_PRECISION // ETH_TO_LDO_RATE

      overpay_amount = 1e18

      allocation = executor.get_allocation(purchaser)
      assert allocation[0] == purchase_ldo_amount
      assert allocation[1] == eth_cost

      initial_purchaser_balance = purchaser.balance()
      helpers.fund_with_eth(purchaser, eth_cost + overpay_amount)

      assert purchaser.balance() == initial_purchaser_balance + eth_cost + overpay_amount

      dao_eth_balance_before = dao_agent.balance()

      tx = purchaser.transfer(to=executor, amount=eth_cost + overpay_amount, gas_limit=400_000)
      purchase_evt = helpers.assert_single_event_named('PurchaseExecuted', tx)

      assert purchaser.balance() == initial_purchaser_balance + overpay_amount

      assert purchase_evt['ldo_receiver'] == purchaser
      assert purchase_evt['ldo_allocation'] == purchase_ldo_amount
      assert purchase_evt['eth_cost'] == eth_cost

      dao_eth_balance_increase = dao_agent.balance() - dao_eth_balance_before
      assert dao_eth_balance_increase == eth_cost
      assert ldo_token.balanceOf(purchaser) == purchase_ldo_amount


  def test_overpay_should_be_returned_via_execute_purchase(accounts, executor, dao_agent, helpers, ldo_token):
      purchaser = accounts.at(accounts[0], force=True)
      purchase_ldo_amount = LDO_ALLOCATIONS[0]

      eth_cost = purchase_ldo_amount * ETH_TO_LDO_RATE_PRECISION // ETH_TO_LDO_RATE

      overpay_amount = 1e18

      allocation = executor.get_allocation(purchaser)
      assert allocation[0] == purchase_ldo_amount
      assert allocation[1] == eth_cost

      initial_purchaser_balance = purchaser.balance()
      helpers.fund_with_eth(purchaser, eth_cost + overpay_amount)

      assert purchaser.balance() == initial_purchaser_balance + eth_cost + overpay_amount

      dao_eth_balance_before = dao_agent.balance()

      tx = executor.execute_purchase(purchaser, { 'from': purchaser, 'value': eth_cost + overpay_amount })
      purchase_evt = helpers.assert_single_event_named('PurchaseExecuted', tx)

      assert purchaser.balance() == initial_purchaser_balance + overpay_amount

      assert purchase_evt['ldo_receiver'] == purchaser
      assert purchase_evt['ldo_allocation'] == purchase_ldo_amount
      assert purchase_evt['eth_cost'] == eth_cost

      dao_eth_balance_increase = dao_agent.balance() - dao_eth_balance_before
      assert dao_eth_balance_increase == eth_cost
      assert ldo_token.balanceOf(purchaser) == purchase_ldo_amount


  def test_purchase_not_allowed_after_expiration_via_transfer(accounts, executor, helpers):
      chain = Chain()

      purchaser = accounts.at(accounts[0], force=True)
      purchase_ldo_amount = LDO_ALLOCATIONS[0]

      eth_cost = purchase_ldo_amount * ETH_TO_LDO_RATE_PRECISION // ETH_TO_LDO_RATE

      allocation = executor.get_allocation(purchaser)
      assert allocation[0] == purchase_ldo_amount
      assert allocation[1] == eth_cost

      helpers.fund_with_eth(purchaser, eth_cost)

      expiration_delay = executor.offer_expires_at() - chain.time()
      chain.sleep(expiration_delay + 3600)
      chain.mine()
      with reverts("offer expired"):
          purchaser.transfer(to=executor, amount=eth_cost, gas_limit=400_000)


  def test_purchase_not_allowed_after_expiration_via_execute_purchase(accounts, executor, helpers):
      chain = Chain()

      purchaser = accounts.at(accounts[0], force=True)
      purchase_ldo_amount = LDO_ALLOCATIONS[0]

      eth_cost = purchase_ldo_amount * ETH_TO_LDO_RATE_PRECISION // ETH_TO_LDO_RATE

      allocation = executor.get_allocation(purchaser)
      assert allocation[0] == purchase_ldo_amount
      assert allocation[1] == eth_cost

      helpers.fund_with_eth(purchaser, eth_cost)

      expiration_delay = executor.offer_expires_at() - chain.time()
      chain.sleep(expiration_delay + 3600)
      chain.mine()

      with reverts("offer expired"):
          executor.execute_purchase(purchaser, { 'from': purchaser, 'value': eth_cost  })


  def test_recover_unsold_tokens_not_allowed_until_exparation(executor, dao_agent):
      with reverts():
          executor.recover_unsold_tokens()


  def test_recover_unsold_tokens_should_transfer_all_tokens_after_exparation(executor, dao_agent, ldo_token):
      chain = Chain()

      expiration_delay = executor.offer_expires_at() - chain.time()
      chain.sleep(expiration_delay + 3600)
      chain.mine()

      executor_balance = ldo_token.balanceOf(executor)
      dao_agent_balance = ldo_token.balanceOf(dao_agent)

      executor.recover_unsold_tokens()

      assert ldo_token.balanceOf(executor) == 0
      assert ldo_token.balanceOf(dao_agent) == dao_agent_balance + executor_balance
#+END_SRC
